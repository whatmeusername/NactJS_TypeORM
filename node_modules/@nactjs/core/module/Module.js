"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NactModule = exports.createModule = exports.createProvider = void 0;
const index_1 = require("../nact-constants/index");
const index_2 = require("../nact-logger/index");
const index_3 = require("./index");
const index_4 = require("../shared/index");
const NactLogger = (0, index_2.getNactLogger)();
function isInjectArgumentsHasEnoughForFactory(provider) {
    const argsLength = provider?.useFactory?.length ?? -1;
    if (argsLength > 0) {
        return (provider?.injectArguments?.length ?? 0) >= argsLength;
    }
    return true;
}
function getNameFromUseAlias(provider) {
    if (provider.willUse === "useAlias" && provider.useAlias) {
        const aliasValue = provider.useAlias;
        return typeof aliasValue === "string" ? aliasValue : (0, index_4.isClassInstance)(aliasValue) ? aliasValue.name : null;
    }
}
function setReadyForData(data, ready) {
    if (ready && !data.isReady) {
        data.isReady = true;
        if ((0, index_4.isInitializedClass)(data.instance)) {
            const onProviderReadyDescriptor = data?.instance["onInstanceReady"];
            if (onProviderReadyDescriptor && typeof onProviderReadyDescriptor === "function") {
                data.instance.onInstanceReady();
            }
        }
    }
    return data;
}
class NactModule {
    __moduleToken;
    transferModuleKey;
    __moduleSettings;
    __isInited;
    import;
    export;
    providers;
    controllers;
    constructor(settings, transferModuleKey) {
        this.transferModuleKey = transferModuleKey ?? "0";
        this.__moduleToken = (0, index_3.getUniqueToken)(settings.isRoot ? index_3.ROOT_MODULE_TOKEN : index_3.MODULE_TOKEN);
        this.__moduleSettings = {
            providers: settings.providers ?? [],
            controllers: settings.controllers ?? [],
            import: settings.import ?? [],
            export: settings.export ?? [],
            isRoot: settings.isRoot ?? false,
        };
        this.__isInited = false;
        this.providers = [];
        this.controllers = [];
        this.import = [];
        this.export = [];
    }
    // ==== Getters ====
    getExports() {
        return this.export;
    }
    getImports() {
        return this.import;
    }
    getProviders() {
        return this.providers;
    }
    getControllers() {
        return this.controllers;
    }
    // ===== Initialization ====
    initialize(settings) {
        if (!this.__isInited) {
            if (!settings)
                settings = this.__moduleSettings;
            if (settings && this.__isInited === false) {
                this.__mapProviders(settings?.providers ?? []);
            }
        }
    }
    finishInitialization() {
        if ((0, index_3.isAllProviderResolved)(this) && !this.__isInited) {
            this.__mapControllers(this.__moduleSettings?.controllers ?? []);
            (0, index_3.setModuleWaterMark)(this);
            //@ts-ignore// Module Settings should exist till module will be impleted
            this.__moduleSettings = null;
            this.__isInited = true;
        }
    }
    // ---- Tokens ----
    getModuleToken() {
        return this.__moduleToken;
    }
    setUniqueToken(object, prefix) {
        const token = (0, index_3.getUniqueToken)(prefix);
        Reflect.defineMetadata(index_1.INJECTABLE_UNIQUE_TOKEN, token, object);
        return token;
    }
    // ===== Providers Getters ====
    getProvider(providerNameOrToken) {
        //prettier-ignore
        providerNameOrToken = (typeof providerNameOrToken === "string" ? providerNameOrToken : (0, index_4.isClassInstance)(providerNameOrToken) ? providerNameOrToken.name : "");
        const isToken = providerNameOrToken?.startsWith(index_3.PROVIDER_TOKEN) || providerNameOrToken?.startsWith(index_3.CUSTOM_PROVIDER_TOKEN);
        if (isToken) {
            return this.providers.find((provider) => provider.uniqueToken === providerNameOrToken);
        }
        return this.providers.find((provider) => provider.name === providerNameOrToken);
    }
    getProviderFromImport(providerName) {
        return this.import.find((provider) => provider.name === providerName);
    }
    getProviderFromSettings(providerName) {
        const providersFromSettings = this.__moduleSettings?.providers;
        if (providersFromSettings) {
            return providersFromSettings.find((provider) => provider.name === providerName || ((0, index_3.isCustomProvider)(provider) && provider.providerName === providerName));
        }
    }
    __getProviderParams(provider) {
        const constructorParams = [];
        const isCustom = (0, index_3.isCustomProvider)(provider);
        const params = isCustom
            ? (0, index_3.mapCustomProviderArgs)(provider?.injectArguments ?? [])
            : provider.constructorParams.params;
        const paramsCount = isCustom ? params.length : provider.constructorParams.count;
        const providerName = isCustom ? provider.providerName : provider.name;
        if (paramsCount > 0) {
            for (let i = 0; i < paramsCount; i++) {
                const constructorParam = params.find((param) => param.index === i);
                if (constructorParam) {
                    const registeredProvider = this.getProvider(constructorParam.name);
                    if (registeredProvider?.isReady) {
                        constructorParams.push(registeredProvider.instance);
                    }
                    else if (registeredProvider && !registeredProvider.isReady) {
                        return null;
                    }
                    //
                    else {
                        const ProviderDepency = this.getProviderFromSettings(constructorParam.name);
                        if (ProviderDepency) {
                            let provider;
                            if ((0, index_3.isCustomProvider)(ProviderDepency)) {
                                provider = this.__resolveCustomProvider(ProviderDepency);
                            }
                            else {
                                provider = this.__registerProvider(ProviderDepency);
                            }
                            if (provider && provider.isReady) {
                                constructorParams.push(provider.instance);
                            }
                            else
                                return null;
                        }
                        //
                        else {
                            const ImportedDepency = this.getProviderFromImport(constructorParam.name);
                            if (ImportedDepency) {
                                if (!ImportedDepency?.resolved)
                                    return null;
                                constructorParams.push(ImportedDepency.instance);
                            }
                            else if (ImportedDepency === undefined) {
                                if (constructorParam.optional) {
                                    constructorParams.push(undefined);
                                }
                                else {
                                    NactLogger.error(`Nact is missing depending provider "${constructorParam.name} (index: ${constructorParam.index})" for provider "${providerName}". Its must be passed as provider or must imported from other module.`);
                                }
                            }
                        }
                    }
                }
                else
                    constructorParams.push(undefined);
            }
        }
        return constructorParams;
    }
    // ---- Resolving / Updating ----
    __updateProvider(providerToken) {
        const providerToUpdate = this.getProvider(providerToken);
        if (providerToUpdate) {
            const initialProvider = this.getProviderFromSettings(providerToUpdate.name);
            if (initialProvider) {
                if ((0, index_3.isCustomProvider)(initialProvider)) {
                    if (initialProvider.willUse === "useFactory" && !this.__isUsingUnresolvedImports(initialProvider)) {
                        const injectArguments = this.__getProviderParams(initialProvider);
                        if (injectArguments) {
                            const providerValue = initialProvider.useFactory(...injectArguments);
                            providerToUpdate.instance = providerValue;
                            setReadyForData(providerToUpdate, true);
                        }
                        return providerToUpdate;
                    }
                    else if (initialProvider.willUse === "useAlias") {
                        const referenceName = getNameFromUseAlias(initialProvider);
                        const referenceProvider = this.getProvider(referenceName);
                        if (referenceProvider && referenceProvider?.instance) {
                            providerToUpdate.instance = referenceProvider?.instance;
                            setReadyForData(providerToUpdate, true);
                            return providerToUpdate;
                        }
                    }
                }
                else if (!this.__isUsingUnresolvedImports(initialProvider)) {
                    this.__resolveProviderInstance(providerToUpdate, initialProvider);
                    return providerToUpdate;
                }
            }
        }
        return null;
    }
    __resolveCustomProvider(customProvider) {
        let providerValue = undefined;
        let isResolved = true;
        const providerData = {};
        const willUse = customProvider.willUse;
        function hasPropeperty(property) {
            const properties = Object.getOwnPropertyNames(customProvider);
            return properties.includes(property);
        }
        if (willUse === "useFactory" && customProvider.useFactory) {
            if (!isInjectArgumentsHasEnoughForFactory(customProvider)) {
                const useFactoryArgsLength = customProvider?.useFactory?.length ?? 0;
                const injArgsLen = customProvider?.injectArguments?.length ?? 0;
                NactLogger.error(`method useFactory of custom provider "${customProvider.providerName}" expected to get atleast ${useFactoryArgsLength} arguments, ${injArgsLen > 0 ? `but got ${injArgsLen}` : "but no one was passed."}`);
            }
            if (!this.__isUsingUnresolvedImports(customProvider)) {
                const injectArguments = this.__getProviderParams(customProvider);
                if (injectArguments) {
                    providerData.instance = customProvider.useFactory(...injectArguments);
                }
            }
            else {
                isResolved = false;
            }
        }
        else if (willUse === "useAlias" && hasPropeperty("useAlias")) {
            const referenceName = getNameFromUseAlias(customProvider);
            if (referenceName) {
                const moduleHasProviderWithName = this.hasProvider(referenceName, true);
                if (moduleHasProviderWithName) {
                    let referenceProvider = this.getProvider(referenceName);
                    providerData.reference = referenceName;
                    if (!referenceProvider) {
                        referenceProvider = this.__registerProvider(this.getProviderFromSettings(referenceName));
                    }
                    if (!referenceProvider?.isReady)
                        isResolved = false;
                    if (referenceProvider?.isReady) {
                        providerData.instance = referenceProvider.instance;
                    }
                }
                else {
                    NactLogger.error(`method of custom provider "useAlias" tried to find provider "${referenceName}" from module, but isnt exists or provider imported from other parent
	Solutions:
	- useAlias is not using provider instance from module import.
	- provider that will be used for alias exists in module is not exists.
					`);
                }
            }
        }
        else if (willUse === "useClass" && hasPropeperty("useClass")) {
            const classInstance = customProvider.useClass;
            if (!(0, index_4.isInitializedClass)(classInstance)) {
                this.__resolveProviderInstance(providerData, customProvider.useClass);
            }
            else
                providerData.instance = classInstance;
        }
        else {
            providerValue = hasPropeperty("useValue") ? customProvider.useValue : undefined;
            providerData.instance = providerValue;
        }
        setReadyForData(providerData, isResolved);
        providerData.name = customProvider.providerName;
        providerData.uniqueToken = this.setUniqueToken(customProvider, index_3.PROVIDER_TOKEN);
        this.providers.push(providerData);
        (0, index_3.getTransferModule)(this.transferModuleKey)
            .getProviderLocator()
            .push({
            name: customProvider.providerName,
            moduleKey: this.getModuleToken(),
            key: providerData.uniqueToken,
            resolved: isResolved,
            instance: isResolved ? providerData.instance : null,
        });
        return providerData;
    }
    __resolveProviderInstance(provider, instance) {
        let constructorParams = [];
        provider.constructorParams = (0, index_3.getConstructorParametersData)(instance);
        if (provider.constructorParams.params.length > 0) {
            constructorParams = this.__getProviderParams(provider);
        }
        if (constructorParams) {
            provider.instance = new instance(...constructorParams);
            setReadyForData(provider, true);
        }
    }
    __registerProvider = (provider) => {
        if ((0, index_3.isInjectable)(provider) && (0, index_4.isClassInstance)(provider)) {
            if (!this.getProvider(provider.name)) {
                const isInitialized = (0, index_4.isInitializedClass)(provider);
                let isResolved = isInitialized ? true : this.__isUsingUnresolvedImports(provider) ? false : true;
                const providerData = {};
                providerData.name = provider.name;
                providerData.uniqueToken = this.setUniqueToken(provider, index_3.PROVIDER_TOKEN);
                if (!isInitialized && isResolved) {
                    this.__resolveProviderInstance(providerData, provider);
                    if (!providerData.instance)
                        isResolved = false;
                }
                else if (isInitialized) {
                    providerData.instance = provider;
                }
                setReadyForData(providerData, isResolved);
                this.providers.push(providerData);
                (0, index_3.getTransferModule)(this.transferModuleKey)
                    .getProviderLocator()
                    .push({
                    name: provider.name,
                    moduleKey: this.getModuleToken(),
                    key: providerData.uniqueToken,
                    resolved: isResolved,
                    instance: isResolved ? providerData.instance : null,
                });
                return providerData;
            }
        }
        else if ((0, index_3.isCustomProvider)(provider)) {
            return this.__resolveCustomProvider(provider);
        }
    };
    __registerController(controller) {
        const getControllerParams = (controllerData) => {
            const params = [];
            if (controllerData.constructorParams.count > 0) {
                for (let i = 0; i < controllerData.constructorParams.count; i++) {
                    const constructorParam = controllerData.constructorParams.params[i];
                    const provider = this.getProvider(constructorParam.name) || this.getProviderFromImport(constructorParam.name);
                    if (provider) {
                        params.push(provider.instance);
                    }
                    else {
                        NactLogger.error(`Cannot resolve provider with name "${constructorParam.name} (index: ${constructorParam.index})" for contorller "${controllerData.name}". Nact not found provider`);
                    }
                }
            }
            return params;
        };
        function resolveControllerInstance(controller, instance) {
            let constructorParams = [];
            controller.constructorParams = (0, index_3.getConstructorParametersData)(instance);
            if (controller.constructorParams.params.length > 0) {
                constructorParams = getControllerParams(controller);
            }
            controller.instance = new instance(...constructorParams);
            setReadyForData(controller, true);
        }
        if ((0, index_3.isController)(controller)) {
            if (!(0, index_3.isInjectable)(controller)) {
                const controllerData = {};
                controllerData.name = controller.name;
                resolveControllerInstance(controllerData, controller);
                this.controllers.push(controllerData);
                (0, index_3.getTransferModule)(this.transferModuleKey)
                    .getProviderLocator()
                    .push({
                    name: controllerData.name,
                    moduleKey: this.getModuleToken(),
                    key: controllerData.uniqueToken,
                    resolved: controllerData.isReady,
                    instance: controllerData.isReady ? controllerData.instance : null,
                });
            }
            else {
                NactLogger.error(`Controllers not allowed to be injectable as same time, but controller "${controller.name}" has injectable flag on.`);
            }
        }
        else {
            NactLogger.warning(`Controller instance must have controller flag on, but got "${controller.name}" without it. (Instance has been passed)`);
        }
    }
    // ==== validating ====
    hasProvider(providerName, shouldBeResolved) {
        return ((this.getProvider(providerName) ?? (shouldBeResolved ? this.getProviderFromSettings(providerName) : undefined)) !==
            undefined);
    }
    __isUsingUnresolvedImports(provider) {
        let res = false;
        const providerNames = [];
        const paramsNames = [];
        const params = (0, index_3.isCustomProvider)(provider)
            ? (0, index_3.mapCustomProviderArgs)(provider.injectArguments)
            : (0, index_3.getConstructorParametersData)(provider, true).params;
        params.forEach((type) => {
            paramsNames.push(type.name);
        });
        this.__moduleSettings?.providers?.forEach((provider) => providerNames.push(provider.name));
        for (let i = 0; i < paramsNames.length; i++) {
            const name = paramsNames[i];
            if (!providerNames.includes(name)) {
                res = this.import.find((imp) => imp.name === name && imp.resolved === false) !== undefined;
                if (res)
                    return res;
            }
        }
        return res;
    }
    // ---- Mapping ---
    __mapProviders(providers) {
        for (let i = 0; i < providers.length; i++) {
            const provider = providers[i];
            this.__registerProvider(provider);
        }
    }
    __mapControllers(controllers) {
        for (let i = 0; i < controllers.length; i++) {
            const controller = controllers[i];
            this.__registerController(controller);
        }
    }
    // ===== EXPORT =====
    __loadExports(exports) {
        for (let i = 0; i < exports.length; i++) {
            const moduleExport = exports[i];
            const exportInstanceName = typeof moduleExport === "string" ? moduleExport : moduleExport.name;
            if (exportInstanceName) {
                const exportedProvider = this.getProviderFromSettings(exportInstanceName);
                if (exportedProvider) {
                    const providerExportData = { name: exportInstanceName, key: exportedProvider.uniqueToken };
                    this.export.push(providerExportData);
                }
            }
        }
    }
}
exports.NactModule = NactModule;
function createModule(settings, transferModulesKey) {
    settings.isRoot = false;
    const newModule = new NactModule(settings, transferModulesKey);
    (0, index_3.getTransferModule)(transferModulesKey).append(newModule);
    return newModule.getModuleToken();
}
exports.createModule = createModule;
function createProvider(settings) {
    if ((0, index_3.isUndefined)(settings.providerName)) {
        NactLogger.error("Custom provider name should not be undefined or be empty");
    }
    function hasPropeperty(property) {
        const properties = Object.getOwnPropertyNames(settings);
        return properties.includes(property);
    }
    if (!hasPropeperty("useFactory") &&
        !hasPropeperty("useValue") &&
        !hasPropeperty("useClass") &&
        !hasPropeperty("useAlias")) {
        NactLogger.error(`Custom provider with name ${settings.providerName} should have useFactory or useValue or useClass or useAlias property provided, but none of them not provided`);
    }
    if (hasPropeperty("useFactory") && typeof settings.useFactory !== "function") {
        NactLogger.error(`Custom providers useFactory property can only accept values with type of "function", but detected type "${typeof settings.useFactory}" in ${settings.useFactory}`);
    }
    if (hasPropeperty("useClass") && !(0, index_4.isClassInstance)(settings?.useClass)) {
        NactLogger.error(`Custom providers useClass property can accept only classes, but detected value type of"${typeof settings.useClass}" in ${settings.providerName}`);
    }
    const isAllowedTypeForAlias = (0, index_4.isClassInstance)(settings?.useAlias) || typeof settings?.useAlias === "string";
    if (hasPropeperty("useAlias") && !isAllowedTypeForAlias) {
        NactLogger.error(`Custom providers useAlias property can only classes or strings, but detected type "${typeof settings.useAlias}" in ${settings.providerName}`);
    }
    // prettier-ignore
    const willUse = settings?.useFactory ? "useFactory" : (settings?.useClass ? "useClass" : (settings.useAlias ? "useAlias" : "useValue"));
    return {
        ...settings,
        uniqueToken: (0, index_3.getUniqueToken)(index_3.CUSTOM_PROVIDER_TOKEN),
        willUse: willUse,
    };
}
exports.createProvider = createProvider;
