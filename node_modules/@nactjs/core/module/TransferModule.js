"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNewTransferModule = exports.getTransferModule = exports.createRootModule = exports.NactTransferModule = void 0;
const tslib_1 = require("tslib");
const index_1 = require("../nact-logger/index");
const CoreModule_1 = tslib_1.__importDefault(require("./CoreModule"));
const index_2 = require("./index");
const index_3 = require("../shared/index");
// const logger = getNactLogger();
const NactLogger = (0, index_1.getNactLogger)();
const transferModulesStorage = new Map();
function createNewTransferModule(key) {
    const tmKey = key ?? "0";
    const newInstance = new NactTransferModule(tmKey);
    transferModulesStorage.set(tmKey, newInstance);
    newInstance.append(new CoreModule_1.default(tmKey));
    return newInstance;
}
exports.createNewTransferModule = createNewTransferModule;
function getTransferModule(key) {
    const tmKey = key ?? "0";
    let NactTransferModuleInstance = transferModulesStorage.get(tmKey);
    if (!NactTransferModuleInstance) {
        NactTransferModuleInstance = createNewTransferModule(tmKey);
    }
    return NactTransferModuleInstance;
}
exports.getTransferModule = getTransferModule;
function createRootModule(settings, key) {
    settings.isRoot = true;
    const newModule = new index_2.NactModule(settings, key);
    return newModule;
}
exports.createRootModule = createRootModule;
class NactTransferModule {
    __modules;
    __exports;
    __rootModules;
    __phase;
    __asyncQueryCount;
    key;
    __providersLocator;
    constructor(key) {
        this.__providersLocator = [];
        this.__modules = [];
        this.__exports = [];
        this.__asyncQueryCount = 0;
        this.__phase = "preparing";
        this.key = key ?? "0";
    }
    // ===== Getters ====
    get length() {
        return this.__modules.length;
    }
    emitProviderEvent(event, key) {
        const provider = this.__providersLocator.find((provider) => provider.key === key);
        if (provider) {
            if (event === "close" && provider.instance.onApplicationShutdown) {
                provider.instance.onApplicationShutdown();
            }
            else if (event === "start" && provider.instance.onApplicationStart) {
                provider.instance.onApplicationStart();
            }
        }
    }
    emitAllProviderEvent(event) {
        for (let i = 0; i < this.__providersLocator.length; i++) {
            const provider = this.__providersLocator[i];
            if (provider) {
                if (event === "close" && provider.instance.onApplicationShutdown) {
                    provider.instance.onApplicationShutdown();
                }
                else if (event === "start" && provider.instance.onApplicationStart) {
                    provider.instance.onApplicationStart();
                }
            }
        }
    }
    getProviderLocator() {
        return this.__providersLocator;
    }
    getCoreModule() {
        return this.__modules.find((module) => module instanceof CoreModule_1.default);
    }
    // ----- Public General ----
    append(module) {
        const append = (module) => {
            if ((0, index_2.isModule)(module)) {
                (0, index_2.unpackModuleArrays)(module);
                this.__modules.push(module);
                module.__loadExports(module.__moduleSettings?.export ?? []);
                this.__getExports(module);
            }
            else if ((0, index_2.isRootModule)(module)) {
                NactLogger.error("Tried append root module as standard module. To append root modules use 'useRootModule' instead.");
            }
        };
        if (Array.isArray(module)) {
            for (let i = 0; i < module.length; i++) {
                append(module[i]);
            }
        }
        else
            append(module);
    }
    useRootModule(settings) {
        const exportAllProviders = (settings) => {
            const providers = settings.providers ?? [];
            settings.export = [];
            for (let i = 0; i < providers.length; i++) {
                const provider = providers[i];
                if ((0, index_2.isCustomProvider)(provider)) {
                    settings?.export?.push(provider.providerName);
                }
                else if ((0, index_3.isClassInstance)(provider)) {
                    settings?.export?.push(provider.name);
                }
            }
            return settings;
        };
        const create = (settings) => {
            exportAllProviders(settings);
            const module = createRootModule(settings, this.key);
            this.__modules.unshift(module);
            module.__loadExports(module.__moduleSettings?.export ?? []);
            this.__getExports(module);
        };
        if (settings instanceof Promise) {
            this.__asyncQueryCount += 1;
            settings.then((response) => {
                create(response);
                this.__asyncQueryCount -= 1;
            });
        }
        else
            create(settings);
    }
    useModule(settings) {
        settings.isRoot = false;
        const newModule = new index_2.NactModule(settings, this.key);
        this.append(newModule);
        return newModule.getModuleToken();
    }
    hasModule(moduleKey) {
        return this.__modules.find((module) => module.getModuleToken() === moduleKey) !== undefined;
    }
    async initialize() {
        const BeginInitalization = () => {
            this.__phase = "resolving";
            for (let i = 0; i < this.__modules.length; i++) {
                const module = this.__modules[i];
                this.__isModuleUsingRootImports(module);
                this.__InitModuleSync(module);
            }
            this.__beginResolvingPhase();
            this.__closingResolvingPhase();
        };
        this.__modules.forEach((module) => {
            if ((0, index_2.isRootModule)(module)) {
                const providers = module?.__moduleSettings?.providers ?? [];
                providers.forEach((provider) => {
                    if ((0, index_2.isCustomProvider)(provider)) {
                        const res = (0, index_2.resolveRootCustomProviderFactory)(provider);
                        if (res instanceof Promise) {
                            this.__asyncQueryCount += 1;
                            res.then(() => (this.__asyncQueryCount -= 1));
                        }
                    }
                });
            }
        });
        let asyncTimeLimit = 1000;
        const timeout = 75;
        const waitForAllAsyncAndBegin = async () => {
            return new Promise((resolve, reject) => {
                if (this.__asyncQueryCount !== 0 && asyncTimeLimit > 0) {
                    setTimeout(async () => {
                        asyncTimeLimit -= timeout;
                        resolve(waitForAllAsyncAndBegin());
                    }, timeout);
                }
                else if (this.__asyncQueryCount === 0) {
                    resolve(BeginInitalization());
                }
                else if (asyncTimeLimit === 0) {
                    resolve(BeginInitalization());
                }
                else {
                    reject();
                }
            });
        };
        await waitForAllAsyncAndBegin();
    }
    // ---- Providers ----
    __getProviderFromLocation(ProviderName) {
        return this.__providersLocator.find((provider) => provider.name === ProviderName);
    }
    // ===== Phases ====
    __beginResolvingPhase() {
        const modulesProvides = this.__providersLocator;
        const countUnresolvedProviders = () => this.__providersLocator.filter((provider) => provider.resolved === false).length;
        let unresProvidersPreviousInter = countUnresolvedProviders();
        while (unresProvidersPreviousInter !== 0) {
            for (let i = 0; i < modulesProvides.length; i++) {
                const provider = modulesProvides[i];
                if (!provider.resolved) {
                    const providerModule = this.__modules.find((module) => module.getModuleToken() === provider.moduleKey);
                    if (providerModule) {
                        this.__resolveModuleImports(providerModule);
                        const response = providerModule.__updateProvider(provider.key);
                        if (response && response.isReady) {
                            provider.resolved = true;
                            provider.instance = response.instance;
                        }
                    }
                }
            }
            const unresProvidersCurrentInter = countUnresolvedProviders();
            if (unresProvidersPreviousInter === unresProvidersCurrentInter) {
                console.log("resolve error");
                break;
            }
            else
                unresProvidersPreviousInter = unresProvidersCurrentInter;
        }
    }
    __closingResolvingPhase() {
        for (let i = 0; i < this.__modules.length; i++) {
            const module = this.__modules[i];
            if (module) {
                module.finishInitialization();
            }
        }
        this.__phase = "ready";
    }
    // ---- Initing ----
    __InitModuleSync(module) {
        if (!module.__isInited) {
            this.__resolveModuleImports(module);
            module.initialize();
        }
    }
    async __InitModuleAsync(module) {
        if (!module.__isInited) {
            this.__resolveModuleImports(module);
            module.initialize();
        }
    }
    // ==== Module Getters =====
    getProviderFromLocationByName(ProviderName) {
        ProviderName = ((0, index_3.isClassInstance)(ProviderName) ? ProviderName.name : ProviderName);
        let provider = this.__getProviderFromLocation(ProviderName);
        if (!provider) {
            for (let i = 0; i < this.__modules.length; i++) {
                const module = this.__modules[i];
                if (!module.__isInited) {
                    provider = module.getProviderFromSettings(ProviderName);
                    if (provider)
                        break;
                }
            }
        }
        return provider;
    }
    getModulesControllers(instanceOnly = false) {
        const modules = this.__modules;
        const controllers = [];
        for (let i = 0; i < modules.length; i++) {
            let moduleControllers = modules[i].getControllers();
            if (instanceOnly) {
                moduleControllers = moduleControllers.map((controller) => controller.instance);
            }
            controllers.push(...moduleControllers);
        }
        return controllers;
    }
    __getExports(module) {
        const moduleExport = module.getExports();
        if (moduleExport.length > 0) {
            for (let i = 0; i < moduleExport.length; i++) {
                const exportedProviderData = moduleExport[i];
                if (exportedProviderData) {
                    this.__exports.push({
                        moduleKey: module.getModuleToken(),
                        providerName: exportedProviderData.name,
                    });
                }
            }
        }
    }
    // ----- Imports ------
    __providerCanBeImported(providerName) {
        const exports = this.__exports;
        if (exports.find((ex) => ex.providerName === providerName))
            return true;
        return false;
    }
    __resolveModuleImports(module, imports) {
        const moduleSettingsImports = imports ?? module.__moduleSettings?.import ?? [];
        if (moduleSettingsImports.length > 0) {
            for (let i = 0; i < moduleSettingsImports.length; i++) {
                const moduleImport = moduleSettingsImports[i];
                const currentImportName = typeof moduleImport === "string" ? moduleImport : moduleSettingsImports[i].name;
                if (this.__providerCanBeImported(currentImportName)) {
                    const moduleImports = module.getImports();
                    if (!(0, index_2.moduleHasImport)(module, currentImportName)) {
                        const importedProvider = this.__getProviderFromLocation(currentImportName);
                        if (importedProvider) {
                            moduleImports.push(importedProvider);
                        }
                        else {
                            const unresolvedProvider = this.getProviderFromLocationByName(currentImportName);
                            if (unresolvedProvider) {
                                const providerName = unresolvedProvider.name ?? unresolvedProvider.providerName;
                                moduleImports.push({
                                    name: providerName,
                                    moduleKey: unresolvedProvider.moduleKey,
                                    resolved: false,
                                    instance: null,
                                    key: null,
                                });
                            }
                        }
                    }
                    else {
                        const importedProvider = this.__getProviderFromLocation(currentImportName);
                        const importPosition = moduleImports.findIndex((imp) => imp.name === currentImportName && imp.resolved === false);
                        if (importPosition !== -1)
                            moduleImports[importPosition] = importedProvider;
                    }
                }
            }
        }
    }
    // ===== Validating =====
    __isModuleUsingRootImports(module) {
        const result = { r: false, p: [] };
        const moduleSettings = module.__moduleSettings;
        const initialProviders = moduleSettings?.providers ?? [];
        const initialControllers = moduleSettings?.controllers ?? [];
        const rootExports = this.__exports.filter((exp) => exp.moduleKey.startsWith(index_2.ROOT_MODULE_TOKEN) === true);
        const moduleNotImportedModules = [];
        const moduleImports = moduleSettings?.import?.map((imp) => (typeof imp === "string" ? imp : imp?.name));
        let providersParameters = [];
        const resolveGlobalImports = () => {
            for (let i = 0; i < providersParameters.length; i++) {
                const param = providersParameters[i];
                if (!moduleNotImportedModules.includes(param.name) && !moduleImports?.includes(param.name)) {
                    const importIndex = rootExports.findIndex((exp) => exp.providerName === param.name);
                    if (importIndex !== -1) {
                        moduleSettings?.import?.push(rootExports[importIndex].providerName);
                    }
                }
            }
        };
        for (let i = 0; i < initialProviders.length; i++) {
            if ((0, index_2.isCustomProvider)(initialProviders[i])) {
                const customProvider = initialProviders[i];
                moduleNotImportedModules.push(customProvider.providerName);
                if (customProvider?.injectArguments) {
                    const injectArguments = (0, index_2.mapCustomProviderArgs)(customProvider.injectArguments);
                    providersParameters = [...providersParameters, ...injectArguments];
                }
            }
            else if ((0, index_3.isClassInstance)(initialProviders[i])) {
                const provider = initialProviders[i];
                moduleNotImportedModules.push(provider.name);
                const providerParameters = (0, index_2.getConstructorParametersData)(provider, true);
                providersParameters = [...providersParameters, ...providerParameters.params];
            }
        }
        for (let i = 0; i < initialControllers.length; i++) {
            const controller = initialControllers[i];
            const controllerParameters = (0, index_2.getConstructorParametersData)(controller, true);
            providersParameters = [...providersParameters, ...controllerParameters.params];
        }
        resolveGlobalImports();
        return result;
    }
}
exports.NactTransferModule = NactTransferModule;
