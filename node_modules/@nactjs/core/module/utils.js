"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRootCustomProviderFactory = exports.unpackModuleArrays = exports.getConstructorParametersData = exports.mapCustomProviderArgs = exports.getUniqueToken = exports.getParamTypes = exports.setModuleWaterMark = exports.isAllProviderResolved = exports.moduleHasImport = exports.isCustomProvider = exports.isController = exports.isInjectable = exports.isRootModule = exports.isModule = exports.isUndefined = void 0;
const index_1 = require("../nact-constants/index");
const index_2 = require("./index");
const index_3 = require("../nact-logger/index");
const index_4 = require("../shared/index");
const NactLogger = (0, index_3.getNactLogger)();
function isUndefined(value) {
    return value === undefined || value === null || (typeof value === "string" && value.trim() === "");
}
exports.isUndefined = isUndefined;
function isRootModule(module) {
    return module?.getModuleToken()?.startsWith(index_2.ROOT_MODULE_TOKEN);
}
exports.isRootModule = isRootModule;
function isModule(module) {
    return module?.getModuleToken()?.startsWith(index_2.MODULE_TOKEN);
}
exports.isModule = isModule;
function isCustomProvider(provider) {
    return typeof provider === "object" && provider?.uniqueToken?.startsWith(index_2.CUSTOM_PROVIDER_TOKEN);
}
exports.isCustomProvider = isCustomProvider;
function isInjectable(object) {
    return Reflect.getMetadata(index_1.INJECTABLE_WATERMARK, object) ? true : false;
}
exports.isInjectable = isInjectable;
function isController(object) {
    return Reflect.getMetadata(index_1.CONTROLLER__WATERMARK, object) ? true : false;
}
exports.isController = isController;
function moduleHasImport(module, importName) {
    return module.getImports().find((imp) => imp.name === importName) !== undefined;
}
exports.moduleHasImport = moduleHasImport;
function isAllProviderResolved(module) {
    const providers = module.getProviders();
    for (let i = 0; i < providers.length; i++) {
        const provider = providers[i];
        if (provider.instance === undefined)
            return false;
    }
    return true;
}
exports.isAllProviderResolved = isAllProviderResolved;
function setModuleWaterMark(module) {
    Reflect.defineMetadata(index_1.MODULE__WATERMARK, true, module);
}
exports.setModuleWaterMark = setModuleWaterMark;
function getParamTypes(object) {
    return Reflect.getMetadata("design:paramtypes", object);
}
exports.getParamTypes = getParamTypes;
function getUniqueToken(prefix) {
    return (prefix ? `${prefix}-` : "") + Math.random().toString(36).slice(5) + "-" + Math.random().toString(36).slice(5);
}
exports.getUniqueToken = getUniqueToken;
function mapCustomProviderArgs(params) {
    const res = [];
    if (params) {
        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            if ((0, index_4.isClassInstance)(param)) {
                res.push({ name: param.name, index: i, type: "class" });
            }
            else if (typeof param === "string") {
                res.push({ name: param, index: i, type: "inject" });
            }
            else if (typeof param === "object") {
                const provide = param.provide;
                if (provide) {
                    // prettier-ignore
                    const paramName = (0, index_4.isClassInstance)(provide) ? provide.name : (typeof provide === "string" ? provide : undefined);
                    if (paramName) {
                        const paramData = { name: paramName, index: i, type: "inject" };
                        if (param?.optional !== undefined)
                            paramData.optional = param.optional;
                        res.push(paramData);
                    }
                }
            }
        }
    }
    return res;
}
exports.mapCustomProviderArgs = mapCustomProviderArgs;
function getConstructorParametersData(provider, validateType) {
    const types = getParamTypes(provider);
    const res = { params: [], count: 0 };
    const injectableProperties = Reflect.getMetadata(index_1.PROPERTY_DEPENDENCIES, provider);
    if (injectableProperties)
        res.params = [...res.params, ...injectableProperties];
    function isInjectedProperty(index) {
        return res.params.find((param) => param.index === index && param.type === "inject") !== undefined;
    }
    if (types) {
        for (let i = 0; i < types.length; i++) {
            const paramType = types[i];
            if (!isInjectedProperty(i)) {
                if (paramType === undefined && !validateType) {
                    NactLogger.error(`Cannot resolve constructor parameter of class "${provider.name}" with index ${i}, because of "${paramType}" value. Maybe is circular dependency, that not cant be handled.`);
                }
                else if (!(0, index_4.isClassInstance)(paramType) && !validateType) {
                    NactLogger.warning(`Parameter of class constructor "${provider.name}" with type "| ${paramType} |" and index ${i} will not be injected due is not class instance.`);
                }
                else if ((0, index_4.isClassInstance)(paramType)) {
                    res.params.push({ name: paramType.name, index: i, type: "class" });
                }
            }
            res.count += 1;
        }
    }
    if (injectableProperties)
        res.params.sort((a, b) => a.index - b.index);
    return res;
}
exports.getConstructorParametersData = getConstructorParametersData;
function unpackModuleArrays(module) {
    if (!module.__isInited) {
        const moduleSettings = module.__moduleSettings;
        const providers = moduleSettings?.providers;
        if (providers) {
            let flattedProviders = [];
            for (let i = 0; i < providers.length; i++) {
                const provider = providers[i];
                if (Array.isArray(provider)) {
                    flattedProviders = [...flattedProviders, ...provider];
                }
                else
                    flattedProviders.push(provider);
            }
            moduleSettings.providers = flattedProviders;
        }
    }
}
exports.unpackModuleArrays = unpackModuleArrays;
function resolveRootCustomProviderFactory(provider) {
    if (provider.useFactory) {
        if (provider.injectArguments) {
            NactLogger.error("Nact root modules cant use imports or injectArguments for custom providers");
        }
        const factoryValue = provider.useFactory();
        provider.willUse = "useValue";
        if (factoryValue instanceof Promise) {
            factoryValue.then((res) => {
                provider.useValue = res;
            });
            return factoryValue;
        }
        else
            provider.useValue = factoryValue;
        delete provider.useFactory;
    }
}
exports.resolveRootCustomProviderFactory = resolveRootCustomProviderFactory;
