"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NactServer = void 0;
require("reflect-metadata");
const http_1 = require("http");
const url_1 = require("url");
const os_1 = require("os");
const net_1 = require("net");
const logger_1 = require("../nact-logger/logger");
const NactRouteLibary_1 = require("../routing/NactRouteLibary");
const nact_request_1 = require("../nact-request");
const module_1 = require("../module");
const expections_1 = require("../expections");
function runMiddlewares(middlewares, NactRequest) {
    for (let i = 0; i < middlewares.length; i++) {
        if (!NactRequest.isSended()) {
            const middleware = middlewares[i];
            middleware(NactRequest);
        }
        else
            return false;
    }
    return true;
}
class NactGlobalConfig {
    server;
    middleware;
    handlers;
    // handlers
    // guards
    // pipes
    //afterware
    constructor(server) {
        this.server = server;
        this.middleware = [];
        this.handlers = [];
    }
    getGlobalMiddleware() {
        return this.middleware;
    }
    getHandlers(name) {
        if (name) {
            return this.handlers.find((handler) => handler.name === name);
        }
        return this.handlers;
    }
    addGlobalHandler(handler) {
        const coreModule = this.server.getTransferModule().getCoreModule();
        if (Array.isArray(handler)) {
            handler.forEach((handler) => {
                const provider = coreModule?.appendProvider(handler);
                if (provider?.instance) {
                    this.handlers = [...this.handlers, ...provider.instance];
                }
            });
        }
        else {
            const provider = coreModule?.appendProvider(handler);
            if (provider?.instance) {
                this.handlers.unshift(provider.instance);
            }
        }
    }
    addGlobalMiddleware(middleware) {
        if (Array.isArray(middleware)) {
            this.middleware = [...this.middleware, ...middleware];
        }
        else {
            this.middleware.push(middleware);
        }
    }
}
class NactServer {
    server;
    serverRunningURL;
    serverPort;
    RouteLibrary;
    IPv4;
    logger;
    GlobalConfig;
    running;
    transferModuleKey;
    listeners;
    constructor(transferModuleKey, serverSetting) {
        this.server = (0, http_1.createServer)({ ServerResponse: nact_request_1.NactServerResponse, IncomingMessage: nact_request_1.NactIncomingMessage }, this.__RequestHandler);
        this.serverRunningURL = null;
        this.serverPort = null;
        this.logger = (0, logger_1.createSharedNactLogger)({ isEnable: serverSetting?.loggerEnabled ?? true });
        this.RouteLibrary = new NactRouteLibary_1.NactRouteLibrary(this, undefined, { logger: this.logger });
        this.IPv4 = null;
        this.GlobalConfig = new NactGlobalConfig(this);
        this.running = false;
        this.transferModuleKey = transferModuleKey ?? "0";
        this.listeners = { start: [], close: [] };
    }
    // --- subscribers
    on(event, cb) {
        if (this.listeners[event] && typeof cb === "function") {
            this.listeners[event].push(cb);
        }
        else {
            this.logger.warning(`tried to subscribe on ${event} event, that not exists defined in nact`);
        }
    }
    emit(event) {
        const events = this.listeners[event];
        if (event && Array.isArray(events)) {
            for (let i = 0; i < events.length; i++) {
                events[i]();
            }
        }
    }
    // ---- Global ----
    getGlobalConfig() {
        return this.GlobalConfig;
    }
    useMiddleware(middleware) {
        this.GlobalConfig.addGlobalMiddleware(middleware);
        this.logger.info(`"${middleware.name ?? "NAME IS UNKNOWN"}" function is now used as global middleware`, "MIDDLEWARE");
        return this;
    }
    useHandler(handler) {
        this.GlobalConfig.addGlobalHandler(handler);
        return this;
    }
    // ==== Getters =====
    getServerURL() {
        if (this.running) {
            return this.serverRunningURL;
        }
        return null;
    }
    getServer() {
        return this.server;
    }
    getLogger() {
        return this.logger;
    }
    getTransferModuleKey() {
        return this.transferModuleKey;
    }
    // ===== Initilization =====
    async __initialize() {
        this.useHandler(expections_1.BaseHttpExpectionHandler);
        await this.getTransferModule().initialize();
        const controllers = this.getTransferModule().getModulesControllers(true);
        this.RouteLibrary.registerController(controllers);
        this.getTransferModule().emitAllProviderEvent("start");
        this.on("close", () => {
            this.getTransferModule().emitAllProviderEvent("close");
        });
        this.__getLocalMachineIP();
        this.__messageOnInitilizationEnd();
    }
    __messageOnInitilizationEnd() {
        if (this.running) {
            const protocol = "http://";
            const ipv4 = this.IPv4 ?? "localhost";
            const serverURL = protocol + ipv4 + ":" + this.serverPort + "/";
            this.serverRunningURL = serverURL;
            this.logger.log(`NactServer is now running on ${serverURL}`);
            this.logger.log("NactServer is successfully configured");
        }
    }
    // ---- Protected utils ----
    __getLocalMachineIP() {
        const net = (0, os_1.networkInterfaces)();
        const en0 = net.en0;
        if (en0) {
            if (en0[1]) {
                const IPv4 = en0[1].address;
                this.IPv4 = IPv4;
            }
        }
    }
    __RequestHandler = (req, res) => {
        const request = new nact_request_1.NactRequest(req, res);
        request.getRequest().once("end", () => {
            this.__executeRequest(request);
        });
    };
    async __executeRequest(request) {
        let response = undefined;
        if (runMiddlewares(this.GlobalConfig.getGlobalMiddleware(), request)) {
            const HandlerRouter = this.RouteLibrary.getRouteMethodOr404(request);
            const handlerData = request.getHandlerData();
            if (HandlerRouter) {
                response = new Promise((resolve) => {
                    return resolve(handlerData?.callMethod());
                });
                await response
                    .then((res) => {
                    request.setPayload(res);
                })
                    .catch((err) => {
                    const routeConfig = HandlerRouter.getControllerHandler();
                    const isHandled = routeConfig.handle(err, request);
                    if (!isHandled) {
                        throw err;
                    }
                });
            }
        }
        return request.send();
    }
    // ==== Public ====
    getTransferModule() {
        return (0, module_1.getTransferModule)(this.transferModuleKey);
    }
    get() {
        return this.server;
    }
    listen(port) {
        if (!this.running) {
            this.server.listen(port, () => {
                this.__initialize();
                this.running = true;
                this.serverPort = port;
            });
        }
        return this;
    }
    async offline() {
        if (!this.running) {
            await this.__initialize();
            this.running = true;
        }
        return this;
    }
    resetConfiguration() {
        this.GlobalConfig = new NactGlobalConfig(this);
    }
    async clearModuleConfiguration(cb) {
        const transferModule = (0, module_1.createNewTransferModule)(this.transferModuleKey);
        this.RouteLibrary.clear();
        if (cb)
            cb(this.transferModuleKey, this.getTransferModule());
        await transferModule.initialize();
        const controllers = this.getTransferModule().getModulesControllers(true);
        this.RouteLibrary.registerController(controllers);
    }
    async injectRequest(RequestData) {
        RequestData.url = RequestData.url.toLowerCase();
        const URLdata = (0, url_1.parse)(RequestData.url);
        function getHTTPRequest() {
            function setURL(req) {
                req.url = URLdata.pathname + (URLdata.search ? URLdata.search : "");
            }
            function setHost(req) {
                req.headers.host = RequestData.headers?.host || (RequestData?.authority ?? false) || (URLdata.host ?? "");
            }
            function setHttpVersion(req) {
                req.httpVersionMajor = 1;
                req.httpVersionMinor = 1;
                req.httpVersion = "1.1";
            }
            function setMethod(req) {
                req.method = RequestData.method ? RequestData.method.toUpperCase() : "GET";
            }
            function setHeaders(req) {
                if (RequestData?.headers) {
                    const headersData = Object.entries(RequestData.headers);
                    for (let i = 0; i < headersData.length; i++) {
                        const header = headersData[i];
                        if (header[1] !== undefined && header[1] !== null) {
                            req.headers[header[0]] = header[1];
                        }
                    }
                }
            }
            function setUserAgent(req) {
                req.headers["user-agent"] = RequestData.headers ? RequestData.headers["user-agent"] : "NactFakeRequest";
            }
            function setRawHeaders(req) {
                const headersData = Object.entries(req.headers);
                for (let i = 0; i < headersData.length; i++) {
                    const [key, value] = headersData[i];
                    if (value !== undefined && value !== null) {
                        req.rawHeaders.push(key);
                        Array.isArray(value) ? req.rawHeaders.push(...value) : req.rawHeaders.push(value);
                    }
                }
            }
            const rawRequest = new nact_request_1.NactIncomingMessage(new net_1.Socket());
            if (RequestData.body !== undefined) {
                rawRequest.emit("data", RequestData.body);
            }
            setURL(rawRequest);
            setHost(rawRequest);
            setHttpVersion(rawRequest);
            setMethod(rawRequest);
            setHeaders(rawRequest);
            setUserAgent(rawRequest);
            setRawHeaders(rawRequest);
            return rawRequest;
        }
        const request = getHTTPRequest();
        const response = new nact_request_1.NactServerResponse(request);
        const nactRequest = new nact_request_1.NactRequest(request, response);
        return await this.__executeRequest(nactRequest);
    }
}
exports.NactServer = NactServer;
