"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NactRouter = exports.getRegexpPresets = exports.NactRouteLibrary = void 0;
// TODO REPLACE LATER
const index_1 = require("../shared/index");
const utils_1 = require("./utils");
const index_2 = require("../index");
const router_class_1 = require("./router-class");
Object.defineProperty(exports, "NactRouter", { enumerable: true, get: function () { return router_class_1.NactRouter; } });
const defaultRegexpPresets = {
    presets: {
        "*": ".*",
        str: "^\\D+$",
        num: "^\\d+$",
    },
    variables: {},
};
const getRegexpPresets = () => {
    return defaultRegexpPresets;
};
exports.getRegexpPresets = getRegexpPresets;
const addPrefixToPath = (path, prefix) => {
    if (path instanceof RegExp) {
        const regexAsString = (0, index_1.removeSlashes)(path.toString());
        const res = (prefix + "/" + `(${regexAsString})`).toLowerCase();
        return res;
    }
    const isSlashOnly = path === "/";
    const res = (prefix + (isSlashOnly ? "" : "/") + (0, index_1.removeSlashes)(path)).toLowerCase();
    return res;
};
function handleRouteDataInjections(target, descriptorKey) {
    if (!target)
        return {};
    const routeConfig = (0, utils_1.getRouteConfig)(target, descriptorKey);
    if (routeConfig) {
        const routeConfigValues = Object.values(routeConfig);
        for (let i = 0; i < routeConfigValues.length; i++) {
            const configItems = routeConfigValues[i]?.fns ?? [];
            for (let j = 0; j < configItems.length; j++) {
                const configItem = configItems[i];
                if (typeof configItem === "object" && configItem?.inject === true) {
                    const tm = (0, index_2.getTransferModule)();
                    const coreModule = tm.getCoreModule();
                    if (coreModule) {
                        let existedProvider = coreModule.getProvider(configItem.instance);
                        if (!existedProvider) {
                            existedProvider = coreModule.appendProvider(configItem.instance);
                        }
                        if (existedProvider?.isReady) {
                            configItem.instance = existedProvider.instance;
                        }
                    }
                }
            }
        }
        (0, utils_1.setRouteConfig)(routeConfig, target, descriptorKey);
    }
    return routeConfig;
}
class NactRouteLibrary {
    app;
    __routes;
    __logger;
    regexpVariables;
    constructor(app, controllers, config) {
        this.app = app;
        this.__routes = {};
        this.__logger = config?.logger ?? (0, index_2.getNactLogger)();
        this.regexpVariables = defaultRegexpPresets;
        if (controllers)
            this.registerController(controllers);
    }
    registerController(controllerClass) {
        const getDescriptorKeys = (prototype) => {
            if (prototype) {
                return Object.keys(Object.getOwnPropertyDescriptors(prototype));
            }
            return [];
        };
        controllerClass = Array.isArray(controllerClass) ? controllerClass : [controllerClass];
        controllerClass.forEach((controller) => {
            const controllerConstructor = controller.constructor;
            const contorllerRoutePath = (0, utils_1.getControllerPath)(controllerConstructor);
            handleRouteDataInjections(controller);
            if (contorllerRoutePath) {
                const controllerData = new router_class_1.NactRouter(controller, this.app);
                this.__routes[contorllerRoutePath] = controllerData;
                const contorllerDescriptorKeys = getDescriptorKeys(controllerConstructor.prototype);
                const registeredRoutesMessage = [];
                for (let i = 0; i < contorllerDescriptorKeys.length; i++) {
                    const descriptorKey = contorllerDescriptorKeys[i];
                    const routeData = this.getRouteMetadata(controllerConstructor, descriptorKey);
                    if (routeData) {
                        const routeMethodsData = Object.values(routeData);
                        for (let i = 0; i < routeMethodsData.length; i++) {
                            const methodData = routeMethodsData[i];
                            const methodPathsData = methodData.data;
                            let routesPaths = methodData.paths;
                            routesPaths = routesPaths.map((path) => addPrefixToPath(path, contorllerRoutePath));
                            const routePathData = this.getOrSetMetadataForRoute(controller, descriptorKey, methodData.method, routesPaths)?.data;
                            if (routePathData) {
                                const routePathDataLength = methodPathsData.length;
                                for (let i = 0; i < routePathDataLength; i++) {
                                    const routeParams = methodPathsData[i];
                                    if (routeParams) {
                                        controllerData.addRoute(routeParams);
                                    }
                                }
                                let message = descriptorKey;
                                if (routePathDataLength > 1) {
                                    const pathsNames = methodPathsData.reduce((prev, next, i) => {
                                        prev += `${next.path}${i !== routePathDataLength - 1 ? ", " : ""}`;
                                        return prev;
                                    }, "");
                                    message = `${descriptorKey} (path: ${pathsNames})`;
                                }
                                registeredRoutesMessage.push(message);
                            }
                        }
                    }
                }
                this.__logger.log(`successfully registered "${controllerConstructor.name}" controller with routes methods with names: \n"${registeredRoutesMessage.join(", ")}". \nTotal: ${registeredRoutesMessage.length} routes`);
            }
        });
    }
    walkRoute(Router, params) {
        const absolutePath = params.path.join("/");
        const method = params.method;
        let route = null;
        if (Router.hasAbsolute(absolutePath, method))
            route = Router.getChild(absolutePath, method);
        else
            route = (0, utils_1.findRouteByParams)(Router, params);
        if (route) {
            //@ts-ignore
            return route;
        }
        return null;
    }
    getRouteParams(rc, routeKEY, req) {
        const routeMetadata = Reflect.getMetadata(index_2.ROUTE__PARAMETER__METADATA, rc, routeKEY);
        let methodParamsVariables = [];
        if (routeMetadata) {
            const methodParams = routeMetadata[index_2.ROUTE__PARAMS] ?? [];
            methodParamsVariables = (0, utils_1.getRouteParameters)(methodParams, req);
        }
        return methodParamsVariables;
    }
    getRouteMethodOr404(req) {
        const params = req.getURLData().params;
        const method = req.getMethod();
        const firstParam = params[0];
        const Router = this.__routes[firstParam] ?? this.__routes["/"];
        if (Router) {
            const route = this.walkRoute(Router, { path: params, method: method });
            if (route) {
                const controllerInstance = Router.getInstance();
                //@ts-ignore getting method from Class Instance
                const routeHandlerData = new index_2.RouteHandlerData(controllerInstance, controllerInstance[route.name], route);
                req.__handler = routeHandlerData;
                routeHandlerData.__routeArgs = this.getRouteParams(controllerInstance.constructor, route.name, req);
                return Router;
            }
            else {
                req.getResponse().status(404);
            }
        }
        else {
            req.getResponse().status(404);
        }
    }
    getRouteMetadata(desc, key, dataOnly) {
        const metadata = Reflect.getMetadata(index_2.ROUTE__PATHS, desc, key);
        return dataOnly ? metadata?.data : metadata;
    }
    getOrSetMetadataForRoute(controller, descriptorKey, method, overidedPaths) {
        const metadata = this.getRouteMetadata(controller.constructor, descriptorKey);
        if (metadata) {
            const methodData = metadata[method];
            if (methodData) {
                if (!overidedPaths && methodData.paths.length === methodData.data.length) {
                    return methodData;
                }
                const pathsLength = methodData.paths.length;
                if (overidedPaths) {
                    methodData.paths = overidedPaths;
                }
                const routeMetaData = methodData.data;
                const paths = methodData.paths;
                for (let i = 0; i < pathsLength; i++) {
                    let path = paths[i];
                    path = (0, index_2.isUndefined)(path) ? "/" : path;
                    handleRouteDataInjections(controller, descriptorKey);
                    const routeData = (0, utils_1.getRouteData)(path, methodData.method, descriptorKey);
                    routeMetaData.push(routeData);
                }
                Reflect.defineMetadata(index_2.ROUTE__PATHS, metadata, controller.constructor, descriptorKey);
                return methodData;
            }
        }
    }
    clear() {
        this.__routes = {};
    }
}
exports.NactRouteLibrary = NactRouteLibrary;
