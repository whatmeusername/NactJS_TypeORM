"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setRouteConfig = exports.getRouteConfig = exports.getControllerPath = exports.getRouteData = exports.diffRouteSchemas = exports.findRouteByParams = exports.getRouteParameters = exports.getPathSchema = void 0;
const index_1 = require("../index");
const index_2 = require("../index");
const NactRouteLibary_1 = require("./NactRouteLibary");
const shared_1 = require("../shared");
const logger = (0, index_2.getNactLogger)();
function findRouteByParams(Router, lookfor) {
    const routeChilds = Object.values(Router.getChild());
    const absolutePaths = Router.getAbsolute();
    const optionalRoutes = [];
    const method = lookfor.method;
    const absolutePath = lookfor.path.join("/");
    for (let i = 0; i < absolutePaths.length; i++) {
        const nameWithMethod = absolutePaths[i] + "#" + method;
        if (absolutePath === nameWithMethod) {
            return Router.getChild(nameWithMethod);
        }
    }
    for (let i = 0; i < routeChilds.length; i++) {
        const route = routeChilds[i];
        if (route.method === method) {
            const mathcing = diffRouteSchemas(route, lookfor.path);
            if (mathcing === "optional") {
                optionalRoutes.push(route);
            }
            else if (mathcing === "pass")
                return route;
        }
    }
    if (optionalRoutes.length > 0) {
        return optionalRoutes[optionalRoutes.length - 1];
    }
    return null;
}
exports.findRouteByParams = findRouteByParams;
function diffRouteSchemas(Route, lookup) {
    let isPassed = "pass";
    let isOptional = false;
    const s1 = Route.schema;
    if (s1.length >= lookup.length) {
        for (let i = 0; i < s1.length; i++) {
            // TODO: CONTINUE ONLY WITH OPTIONAL ON
            if (isPassed === "pass" || isPassed === "optional") {
                const routePathSeg = s1[i];
                const lookupSeg = lookup[i]
                    ? (typeof lookup[i] === "string" ? lookup[i] : lookup[i].name)
                    : null;
                const routePathName = routePathSeg?.name;
                if (lookupSeg) {
                    if (routePathName === null && routePathSeg.regexp) {
                        isPassed = routePathSeg.regexp.test(lookupSeg) ? "pass" : "fail";
                    }
                    else if (routePathSeg.parameter) {
                        if (routePathSeg?.regexp) {
                            isPassed = routePathSeg.regexp.test(lookupSeg) ? "pass" : "fail";
                        }
                    }
                    else if (routePathSeg?.name && !routePathSeg?.parameter && !routePathSeg?.regexp) {
                        isPassed = routePathName === lookupSeg ? "pass" : "fail";
                    }
                    else if (routePathName === null && !routePathSeg.optional) {
                        isPassed = "fail";
                    }
                    if (routePathSeg?.optional) {
                        isOptional = true;
                    }
                }
                else {
                    if (routePathSeg.optional) {
                        isPassed = "optional";
                        isOptional = true;
                    }
                    else
                        isPassed = "fail";
                }
                if (isPassed === "fail")
                    break;
            }
        }
    }
    else {
        isPassed = "fail";
    }
    return isOptional && isPassed === "pass" ? "optional" : isPassed;
}
exports.diffRouteSchemas = diffRouteSchemas;
function getRouteData(path, method, propertyKey) {
    let clearedPath = path.toString();
    let pathSchema = [];
    let isAbsolute = false;
    let dynamicIndexes = [];
    const isRegex = path instanceof RegExp;
    if (!isRegex) {
        clearedPath = (0, shared_1.removeSlashes)(path);
        pathSchema = getPathSchema(clearedPath);
        dynamicIndexes = [];
        isAbsolute = true;
        pathSchema.forEach((seg, i) => {
            if (seg?.parameter) {
                isAbsolute = false;
                dynamicIndexes.push(i);
            }
            else if (seg?.regexp) {
                isAbsolute = false;
            }
        });
    }
    else if (isRegex) {
        pathSchema = [{ name: null, regexp: path }];
    }
    const data = {
        path: clearedPath,
        name: propertyKey,
        method: method,
        absolute: isAbsolute,
        schema: pathSchema,
        dynamicIndexes: dynamicIndexes,
    };
    if (isRegex)
        data.isRegex = true;
    return data;
}
exports.getRouteData = getRouteData;
function isOptionalPathSegment(path) {
    return path.endsWith("?");
}
function isDynamicPath(path) {
    const re = /^:{1}[A-Za-z0-9_.~-]+$/;
    return re.test(path);
}
function isDynamicWithRegex(path) {
    const re = /^:{1}?[A-Za-z0-9_.~-]+\(.*\)$/;
    return re.test(path);
}
function isRegexPath(path) {
    const re = /^\(.*\)$/;
    return re.test(path);
}
function isAllowedNameForURL(path) {
    const re = /^[A-Za-z0-9_.~-]*$/;
    return re.test(path);
}
function extractNameFromPath(path) {
    const re = /\b[A-Za-z0-9_.~-]+\b/;
    //@ts-ignore Regex will return string or null, but not array
    const res = path.match(re);
    return res ? res[0] : null;
}
function extractRegexFromPath(path, convertToRegEXP) {
    const checkPreset = (re) => {
        const RegexpPresets = (0, NactRouteLibary_1.getRegexpPresets)().presets;
        const preset = RegexpPresets[re];
        if (preset) {
            return preset;
        }
        return re;
    };
    const re = /\(.+\)/g;
    const res = path.match(re);
    let regexpString = res ? res[0] : null;
    if (regexpString) {
        regexpString = checkPreset(regexpString.slice(1, regexpString.length - 1));
        return convertToRegEXP ? new RegExp(regexpString) : regexpString;
    }
    return null;
}
function getPathSchema(path) {
    if (path === "/") {
        return [{ name: "/" }];
    }
    const RegexEmptyError = (seg) => {
        logger.error(`Got empty regexp value from path segment ${seg} of path ${path}. Regexp should not contains empty values.`);
    };
    const res = [];
    const splited = path.split("/");
    for (let i = 0; i < splited.length; i++) {
        let seg = splited[i];
        if (!(0, index_2.isUndefined)(seg)) {
            const data = { name: null };
            const isOptional = isOptionalPathSegment(seg);
            seg = isOptional ? seg.slice(0, seg.length - 1) : seg;
            if (isDynamicWithRegex(seg)) {
                data.parameter = true;
                const name = extractNameFromPath(seg);
                if (name) {
                    data.name = name;
                    const regexp = extractRegexFromPath(seg, true);
                    if (regexp)
                        data.regexp = regexp;
                    else
                        RegexEmptyError(seg);
                }
            }
            else if (isRegexPath(seg)) {
                const regexp = extractRegexFromPath(seg, true);
                if (regexp && `${regexp}`.length > 0) {
                    data.regexp = regexp;
                }
                else {
                    RegexEmptyError(seg);
                }
            }
            else if (isDynamicPath(seg)) {
                data.parameter = true;
                data.name = extractNameFromPath(seg);
            }
            else if (isAllowedNameForURL(seg)) {
                data.name = extractNameFromPath(seg);
            }
            else {
                logger.error(`Part "${seg}" of path "${path}" does not match any allowed pattern.
		Check if:
		1. Make sure if your path is using allowed characters specified in RFC3968 (2.3): (A-Z, a-z, 0-9, _, ., ~, -,). 
		2. If using regex then follow one of these patterns:
			- ( :example(^.*\\D$)"?" ): for parameter path segment
			- ( (^.*\\D$)"?" ): for non parameter path segment
	
			("?" - stands for: allowing using optional)
				`);
            }
            if (isOptional) {
                data.optional = true;
            }
            res.push(data);
        }
    }
    return res;
}
exports.getPathSchema = getPathSchema;
function getRouteParameters(params, req) {
    const result = [];
    for (let i = 0; i < params.length; i++) {
        const param = params[i];
        if (typeof param === "function") {
            result.push(param(req));
        }
    }
    return result;
}
exports.getRouteParameters = getRouteParameters;
function getControllerPath(instance) {
    return Reflect.getOwnMetadata(index_1.CONTROLLER_ROUTER__NAME, instance) ?? null;
}
exports.getControllerPath = getControllerPath;
function getRouteConfig(target, descriptorKey) {
    if ((0, shared_1.isInitializedClass)(target)) {
        if (descriptorKey) {
            return Reflect.getMetadata(index_1.ROUTE__CONFIG, target[descriptorKey] ?? {});
        }
        else {
            const classProto = Object.getPrototypeOf(target).constructor;
            return Reflect.getMetadata(index_1.ROUTE__CONFIG, classProto);
        }
    }
    else if ((0, shared_1.isClassInstance)(target)) {
        if (descriptorKey) {
            return Reflect.getMetadata(index_1.ROUTE__CONFIG, target[descriptorKey]);
        }
        else {
            return Reflect.getMetadata(index_1.ROUTE__CONFIG, target);
        }
    }
}
exports.getRouteConfig = getRouteConfig;
function setRouteConfig(config, target, descriptorKey) {
    if ((0, shared_1.isInitializedClass)(target)) {
        if (descriptorKey) {
            Reflect.defineMetadata(index_1.ROUTE__CONFIG, config, target[descriptorKey]);
        }
        else {
            const classProto = Object.getPrototypeOf(target).constructor;
            Reflect.defineMetadata(index_1.ROUTE__CONFIG, config, classProto);
        }
    }
    else if ((0, shared_1.isClassInstance)(target)) {
        if (descriptorKey) {
            Reflect.defineMetadata(index_1.ROUTE__CONFIG, config, target[descriptorKey]);
        }
        else {
            Reflect.defineMetadata(index_1.ROUTE__CONFIG, config, target);
        }
    }
}
exports.setRouteConfig = setRouteConfig;
