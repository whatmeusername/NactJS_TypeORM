"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NactIncomingMessage = exports.NactServerResponse = exports.RouteHandlerData = exports.NactRequest = void 0;
const tslib_1 = require("tslib");
const http_1 = require("http");
const index_1 = require("../index");
const send_1 = require("send");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = require("path");
const utils_1 = require("./utils");
const SendFileDefaultOption = {
    disableWarning: false,
};
class RouteHandlerData {
    ControllerInstance;
    routeClass;
    routeMethod;
    routeData;
    routeArgs;
    constructor(rc, rm, rd) {
        this.ControllerInstance = rc;
        this.routeClass = rc.constructor;
        this.routeMethod = rm;
        this.routeData = rd;
        this.routeArgs = [];
    }
    set __routeMethod(value) {
        this.routeMethod = value;
    }
    set __routeArgs(value) {
        this.routeArgs = value;
    }
    callMethod() {
        if (this.routeMethod) {
            return this.routeMethod.apply(this.ControllerInstance, this.routeArgs);
        }
        return undefined;
    }
    getArgs() {
        return this.routeArgs;
    }
    getHandlerClass() {
        return this.routeClass;
    }
    getHandler() {
        return this.routeMethod;
    }
    getRouteData() {
        return this.routeData;
    }
}
exports.RouteHandlerData = RouteHandlerData;
class NactServerResponse extends http_1.ServerResponse {
    ctx;
    constructor(req) {
        super(req);
        this.ctx = undefined;
    }
    set __ctx(ctx) {
        if (!this.ctx) {
            this.ctx = ctx;
        }
    }
    getCtx() {
        return this.ctx;
    }
    isSended() {
        return this.writableEnded;
    }
    json(body) {
        if (!this.isSended()) {
            const json = JSON.stringify(body);
            this.setHeader("Content-Type", "application/json; charset=utf-8");
            this.length(Buffer.from(json).byteLength);
            this.ctx?.setPayload(body);
            return this.end(json, "utf8");
        }
        return this;
    }
    send(data) {
        if (!this.isSended()) {
            if (data) {
                if (typeof data === "object") {
                    return this.json(data);
                }
                else {
                    const stringifyData = JSON.stringify(data);
                    this.length(Buffer.from(stringifyData).byteLength);
                    this.write(stringifyData);
                    this.ctx?.setPayload(data);
                    return this.end();
                }
            }
            else {
                this.status(index_1.HTTP_STATUS_CODES.NO_CONTENT);
            }
            return this.end(data ? data : null);
        }
        return this;
    }
    contentType(type) {
        if (!this.isSended()) {
            const mimeType = send_1.mime.lookup(type) || type;
            this.setHeader("Content-type", mimeType);
        }
        return this;
    }
    status(code) {
        if (!this.isSended())
            this.statusCode = code;
        return this;
    }
    header(header, value) {
        if (value !== null) {
            if (typeof value === "boolean")
                value = value.toString();
            if (!this.isSended()) {
                this.setHeader(header, value);
            }
        }
        return this;
    }
    length(length) {
        if (!this.isSended())
            this.setHeader("Content-Length", length);
        return this;
    }
}
exports.NactServerResponse = NactServerResponse;
class NactIncomingMessage extends http_1.IncomingMessage {
    body;
    ctx;
    constructor(socket) {
        super(socket);
        this.body = undefined;
        this.ctx = undefined;
        this.on("data", (chunk) => {
            if (chunk instanceof Buffer) {
                this.body = chunk.toString();
            }
            else {
                this.body = chunk;
            }
        });
    }
    set __ctx(ctx) {
        if (!this.ctx) {
            this.ctx = ctx;
        }
    }
    getBody() {
        return this.body;
    }
    getHeader(name) {
        return this.headers[name] ?? null;
    }
}
exports.NactIncomingMessage = NactIncomingMessage;
class NactRequest {
    request;
    response;
    handler;
    host;
    origin;
    method;
    ip;
    protocol;
    urldata;
    payload;
    __logger;
    constructor(req, res) {
        this.request = req;
        this.response = res;
        this.handler = null;
        this.host = (0, utils_1.getHost)(req);
        this.origin = (req.getHeader("Origin") ?? (0, utils_1.getOrigin)(req));
        this.method = req.method ?? null;
        this.ip = (0, utils_1.getRequestIP)(req);
        this.protocol = (0, utils_1.getProtocol)(req);
        this.urldata = (0, utils_1.getRequestURLInfo)(req);
        this.payload = null;
        this.__logger = (0, index_1.getNactLogger)();
        this.request.__ctx = this;
        this.response.__ctx = this;
    }
    set __handler(__handler) {
        //@ts-ignore
        this.handler = __handler;
    }
    // ---- getters ----
    getHandlerClass() {
        return this.handler?.getHandlerClass();
    }
    getHandler() {
        return this.handler?.getHandler();
    }
    getHandlerData() {
        return this.handler;
    }
    getRouteData() {
        return this.handler?.getRouteData();
    }
    getPayload() {
        return this.payload;
    }
    getURLData() {
        return this.urldata;
    }
    getRequest() {
        return this.request;
    }
    getResponse() {
        return this.response;
    }
    getProtocol() {
        return this.protocol;
    }
    getMethod() {
        return this.method;
    }
    getHost() {
        return this.host;
    }
    getOrigin() {
        return this.origin;
    }
    getIP() {
        return this.ip;
    }
    // ---- Setters -----
    setPayload(payload) {
        this.payload = payload;
        return this.payload;
    }
    // ==== Utils =====
    isSended() {
        return this.response.writableEnded;
    }
    send() {
        if (!this.response.isSended()) {
            this.response.send(this.payload);
        }
        return this;
    }
    sendFile(path, options = SendFileDefaultOption) {
        const isFileExists = fs_1.default.existsSync(path);
        const response = this.getResponse();
        if (isFileExists && !this.isSended()) {
            let canStream = true;
            const fileProperties = (0, path_1.parse)(path);
            const fileExtension = fileProperties.ext.slice(1);
            const type = send_1.mime.lookup(fileExtension) || "text/plain";
            const stats = fs_1.default.statSync(path);
            if (options?.maxSize && options?.maxSize < stats.size) {
                canStream = false;
                //this.forbiddenRequest();
                if (!options.disableWarning) {
                    this.__logger.info(`Send file: "${fileProperties.base}" with size of ${stats.size} bytes exceeded limit of ${options?.maxSize} bytes. (Request was cancelled)`);
                }
            }
            if (options?.allowedExtensions) {
                if (Array.isArray(options.allowedExtensions) && !options.allowedExtensions.includes(fileExtension)) {
                    canStream = false;
                }
                else if (options.allowedExtensions !== fileExtension)
                    canStream = false;
                if (!canStream) {
                    //this.forbiddenRequest();
                    if (!options.disableWarning) {
                        this.__logger.info(`Send file: "${fileProperties.base}" with extention "${fileExtension}" not permitted by allowed ${Array.isArray(options.allowedExtensions) ? "extensions" : "extension"} "${options.allowedExtensions}". (Request was cancelled)`);
                    }
                }
            }
            if (canStream) {
                const fileStream = fs_1.default.createReadStream(path);
                fileStream.on("open", () => {
                    response.status(index_1.HTTP_STATUS_CODES.OK).contentType(type).length(stats.size);
                    fileStream.pipe(this.response);
                });
                fileStream.on("end", () => {
                    response.end();
                });
                fileStream.on("error", () => {
                    this.__logger.error(`Send file: Caught error while streaming file "${fileProperties.base}".`);
                    response.end();
                });
            }
        }
        else {
            //this.Request404();
        }
    }
}
exports.NactRequest = NactRequest;
